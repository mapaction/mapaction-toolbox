<?xml version="1.0"?>
<doc>
<assembly>
<name>
api
</name>
</assembly>
<members>
<member name="M:mapaction.datanames.api.AbstractDataName.#ctor(System.String,mapaction.datanames.api.IDataNameClauseLookup@,System.Boolean)">
	<summary>
 Creates a new IDataName.
 </summary>
	<param name="strNewName">The Name. The caller is reasonible for ensuring that
 any prefixes or suffixes specific to a particular storage type are removed before
 being passed to this constructor.
 </param>
	<param name="dncl">The IDataNameClauseLookup object against which the validity of 
 this IDataName will be checked</param>
	<param name="blnAllowRenames">Allows the caller to create the object in readonly 
 mode. Useful if the IDataListConnection would need to be modified to accomidate
 renamed IDataName objects</param>
	<remarks>
 Creates a new IDataName.
 
 The caller is reasonible for ensuring that any prefixes or suffixes specific 
 to a particular storage type are removed before being passed to this constructor.
 The object can be created in readonly mode if required. This is useful if the 
 IDataListConnection would need to be modified to accomidate renamed IDataName 
 objects (eg an MXD).
 </remarks>
</member><member name="M:mapaction.datanames.api.AbstractDataName.getPathStr">
	<summary>
 Returns the path of the current DataName as a String if possible. Should not 
 include trailing slash or backslash.
 </summary>
	<returns>
 a string of the current Data Name's path. Or is a path is not available a null 
 or zero length string is returned.
 </returns>
	<remarks>
 Returns the path of the current Data Name as a String, if a suitable meaning of
 path is applicable. If there is no easy or meaningful sense of a path (eg for a 
 RDBMS) then a null or zero length string is returned.
 
 Should not include trailing slash or backslash.
</remarks>
</member><member name="M:mapaction.datanames.api.AbstractDataName.getUnderlyingDataType">
	<summary>
 This method is used to check that the data type clause matches actually physical data type.
 </summary>
	<returns>One of the constants with the prefix "DATATYPE_CLAUSE_"</returns>
	<remarks>
 This method is used to check that the data type clause matches actually physical data type.
 
 The implenmentor should check the underlying geographical data type and return an 
 appropriate string. This method is called within the checkNameStatus() method to ensure
 that the type specified in the data name matches the underlying geographical type.
 </remarks>
</member><member name="M:mapaction.datanames.api.AbstractDataName.getNameAndFullPathStr">
	<summary>
 Returns the fully qualified IDataName as a String if possible.
 </summary>
	<returns>
 a string of the current IDataName's the fully qualified name. Or is a path is not
 available then just the fully qualified name is returned (ie including the filename
 extension [eg ".shp"] the RDBMS database or RDBMS user name prefixes
 [eg "mapaction.sde."]
 </returns>
	<remarks>
 Returns getPathStr() + "\" + getNameStr()
 Returns the fully qualified IDataName as a String, if a suitable meaning of
 path is applicable. If there is no easy or meaningful sense of a path (eg for a 
 RDBMS) then the fully qualified name is returned (ie including the filename
 extension [eg ".shp"] the RDBMS database or RDBMS user name prefixes
 [eg "mapaction.sde."].
 </remarks>
</member><member name="M:mapaction.datanames.api.AbstractDataName.checkNameStatus">
	<summary>
 This method does the core processing to determine whether or not the particular name represented by 
 this object is syntatically correct and valid or not.
 </summary>
	<returns>A Long which is the sum of the dnNameStatus emnumeration members.</returns>
	<remarks>
 This method does the core processing to determine whether or not the particular name represented by 
 this object is syntatically correct and valid or not. 
 
 The status flags are a sum of the dnNameStatus emnumeration members and are arranged in four categories:
     INVALID = "One or more of the clauses (excluding Free Text) cannot be found in the Data Name Clause Lookup Tables
     SYNTAX_ERROR = "The format of the name cannot be understood. Individual clauses cannot be identified."
     WARN = "The name can be understood and the clauses are valid, but for some reason there is a risk that it will be misinterprited"
     INFO = "Other information about the name"
 
 All of the flags are prefixed with one of these four names. It is possible to test
 for all flags within a particular category by just testing agains the root. eg:
 
 ((myNameStatus And dnNameStatus.SYNTAX_ERROR) = dnNameStatus.SYNTAX_ERROR)
 
 will return true for SYNTAX_ERROR_CONTAINS_HYPHENS, SYNTAX_ERROR_TOO_FEW_CLAUSES,
 SYNTAX_ERROR_DOUBLE_UNDERSCORE and SYNTAX_ERROR_OTHER
 
 There is no "is valid" flag since depending on context this is any 
 combination of "not DATANAME_INVALID", "not DATANAME_SYNTAX_ERROR" 
 and maybe "not DATANAME_WARN"
 </remarks>
</member><member name="M:mapaction.datanames.api.AbstractDataName.isNameParseable">
	<summary>
 Tests whether or not the IDataName is syntatically correct.
 </summary>
	<returns>Boolean. TRUE is the name is syntatically correct, FALSE otherwise</returns>
	<remarks>
 Tests whether or not the IDataName is syntatically correct.
 
 This method is shorthand for:
 (Not (checkNameStatus() And dnNameStatus.SYNTAX_ERROR) = dnNameStatus.SYNTAX_ERROR))
 </remarks>
</member><member name="M:mapaction.datanames.api.AbstractDataName.isNameValid">
	<summary>
 Tests whether or not the Data Name is both syntatically correct and all of the clauses are found in the
 relevant IDataNameClauseLookupTables.
 </summary>
	<returns>
 Boolean. TRUE is the name is syntatically correct AND all of the clauses are found in the
 relevant IDataNameClauseLookupTables, FALSE otherwise
 </returns>
	<remarks>
 Tests whether or not the Data Name is both syntatically correct and all of the clauses are found in the
 relevant IDataNameClauseLookupTables. If optional clauses are present then their values must be found in
 the relevant  IDataNameClauseLookupTables.
 
 This method is shorthand for:
 (Not (checkNameStatus() And dnNameStatus.SYNTAX_ERROR) = dnNameStatus.SYNTAX_ERROR)) _
 and (Not (checkNameStatus() And dnNameStatus.INVALID) = dnNameStatus.INVALID))
 </remarks>
</member><member name="M:mapaction.datanames.api.AbstractDataName.isRenameable">
	<summary>
 Test whether the IDataName can be renamed without an exception being thrown
 </summary>
	<returns>Boolean. Returns a runtime value signifying whether or not the underlying dataname
 is both renaming (physically) and that the relevant permissions are held.
 </returns>
	<remarks>
 Test whether the IDataName can be renamed without an exception being thrown
 
 If true then attempting to calling one of the methods to rename the
 DataName should not throw an expeption. If false then attempting to call one of the method
 will raise a RenamingDataException.
 </remarks>
</member><member name="M:mapaction.datanames.api.AbstractDataName.renamePossible">
	<summary>
 Subclasses should overwrite this. It should return a runtime value indicating
 whether or not the data *could* be renamed. (It is distict from whether or not 
 renaming is *allowed* with the context of the api)
 </summary>
	<returns></returns>
	<remarks>
 Subclasses should overwrite this. It should return a runtime value indicating
 whether or not the data *could* be renamed. (It is distict from whether or not 
 renaming is *allowed* with the context of the api)
 
 The runtime conbination of being both *allowed* and *possible* are combined by 
 the isRenameable() method. End users should call this method.
 </remarks>
</member><member name="M:mapaction.datanames.api.AbstractDataName.resetCacheFlags">
	<summary>
 Used by this class and subclasses to indicate that the internally cached NameStatus
 value is not longer valid. The next call to .checkNameStatus() will result in a full
 check against all of the underlying Data Name Tables.
 </summary>
	<remarks>
 Used by this class and subclasses to indicate that the internally cached NameStatus
 value is not longer valid. The next call to .checkNameStatus() will result in a full
 check against all of the underlying Data Name Tables.
 </remarks>
</member><member name="M:mapaction.datanames.api.AbstractDataName.hasOptionalScaleClause">
	<summary>
 Indicates whether or not the DataName includes an optional scale clause.
 </summary>
	<returns>
 TRUE if the name is parseable and the optional scale clause is present. False otherwise.
 </returns>
	<remarks>
 Indicates whether or not the DataName includes an optional scale clause.
 </remarks>
</member><member name="M:mapaction.datanames.api.AbstractDataName.hasOptionalPermissionClause">
	<summary>
 Indicates whether or not the DataName includes an optional permissions clause.
 </summary>
	<returns>
 TRUE if the name is parseable and the optional permissions clause is present. False otherwise.
 </returns>
	<remarks>
 Indicates whether or not the DataName includes an permissions scale clause.
 </remarks>
</member><member name="M:mapaction.datanames.api.AbstractDataName.hasOptionalFreeText">
	<summary>
 Indicates whether or not the DataName includes an optional free text clause.
 </summary>
	<returns>
 TRUE if the name is parseable and the optional free text clause is present. False otherwise.
 </returns>
	<remarks>
 Indicates whether or not the DataName includes an free text scale clause.
 </remarks>
</member><member name="M:mapaction.datanames.api.AbstractDataName.rename(System.String)">
	<summary>
 Attempts to rename the IDataName, to the newNameStr. The newNameStr does not need to be valid
 in the sense of the data naming convention, but must be valid in terms of the underlying storage.
 </summary>
	<param name="strNewName">The new Name for the IDataName.</param>
	<remarks>
 Attempts to rename the DataName, to the newNameStr. The newNameStr does not need to be valid
 in the sense of the data naming convention, but must be valid in terms of the underlying storage.
 
 If the renaming fails for any reason a RenamingDataException is thrown.
 </remarks>
</member><member name="M:mapaction.datanames.api.AbstractDataName.performRename(System.String)">
	<summary>
 Subclasses should overwrite this. It should implenment a method for
 renaming the underlying data object, specific to teh storage method.
 </summary>
	<param name="newNameStr">The new Name for the IDataName.</param>
	<remarks>
 Subclasses should overwrite this. It should implenment a method for
 renaming the underlying data object, specific to teh storage method.
 
 If the underlying storage is readonly then the implenmenting method
 should throw a RenamingDataException exception.
 
 End users should not call this method, but use the rename() method 
 instead.
 </remarks>
</member><member name="M:mapaction.datanames.api.AbstractDataName.changeGeoExtentClause(System.String)">
	<summary>
 A convenance function, to subsutute the GeoExtent clause of the current name with a new value.
 </summary>
	<param name="strNewGeoExtent">The new, subsutute GeoExtent clause</param>
	<remarks>
 A convenance function, to subsutute the GeoExtent clause of the current name with a new value.
 The new value does not need to be valid in the sense of the data naming convention, but must
 be valid in terms of the underlying storage.
 
 Throws an RenamingDataException if the IDataName is either un-renamable [test with 
 .isRenameable()] or is not syntaticatally correct [test with .isNameParseable()]
 </remarks>
</member><member name="M:mapaction.datanames.api.AbstractDataName.changeDataCategoryClause(System.String)">
	<summary>
 A convenance function, to subsutute the DataCategory clause of the current name with a new value.
 </summary>
	<param name="strNewDataCategory">The new, subsutute DataCategory clause</param>
	<remarks>
 A convenance function, to subsutute the DataCategory clause of the current name with a new value.
 The new value does not need to be valid in the sense of the data naming convention, but must
 be valid in terms of the underlying storage.
 
 Throws an RenamingDataException if the IDataName is either un-renamable [test with 
 .isRenameable()] or is not syntaticatally correct [test with .isNameParseable()]
 </remarks>
</member><member name="M:mapaction.datanames.api.AbstractDataName.changeDataThemeClause(System.String)">
	<summary>
 A convenance function, to subsutute the DataTheme clause of the current name with a new value.
 </summary>
	<param name="strNewDataTheme">The new, subsutute DataTheme clause</param>
	<remarks>
 A convenance function, to subsutute the DataTheme clause of the current name with a new value.
 The new value does not need to be valid in the sense of the data naming convention, but must
 be valid in terms of the underlying storage.
 
 Throws an RenamingDataException if the IDataName is either un-renamable [test with 
 .isRenameable()] or is not syntaticatally correct [test with .isNameParseable()]
 </remarks>
</member><member name="M:mapaction.datanames.api.AbstractDataName.changeDataTypeClause(System.String)">
	<summary>
 A convenance function, to subsutute the DataType clause of the current name with a new value.
 </summary>
	<param name="strNewDataType">The new, subsutute DataType clause</param>
	<remarks>
 A convenance function, to subsutute the DataType clause of the current name with a new value.
 The new value does not need to be valid in the sense of the data naming convention, but must
 be valid in terms of the underlying storage.
 
 Throws an RenamingDataException if the IDataName is either un-renamable [test with 
 .isRenameable()] or is not syntaticatally correct [test with .isNameParseable()]
 </remarks>
</member><member name="M:mapaction.datanames.api.AbstractDataName.changeScaleClause(System.String)">
	<summary>
 A convenance function, to subsutute the Scale clause of the current name with a new value.
 </summary>
	<param name="strNewScale">The new, subsutute Scale clause</param>
	<remarks>
 A convenance function, to subsutute the Scale clause of the current name with a new value.
 The new value does not need to be valid in the sense of the data naming convention, but must
 be valid in terms of the underlying storage.
 
 If the Scale clause is not already present it will be inserted and the relevant undersources
 will be inserted. To completely remove an existing Scale clause set newScaleClause="" and
 the relevant undersorces will be removed.
 
 Throws an RenamingDataException if the IDataName is either un-renamable [test with 
 .isRenameable()] or is not syntaticatally correct [test with .isNameParseable()]
 </remarks>
</member><member name="M:mapaction.datanames.api.AbstractDataName.changeSourceClause(System.String)">
	<summary>
 A convenance function, to subsutute the Source clause of the current name with a new value.
 </summary>
	<param name="strNewSource">The new, subsutute Source clause</param>
	<remarks>
 A convenance function, to subsutute the Source clause of the current name with a new value.
 The new value does not need to be valid in the sense of the data naming convention, but must
 be valid in terms of the underlying storage.
 
 Throws an RenamingDataException if the IDataName is either un-renamable [test with 
 .isRenameable()] or is not syntaticatally correct [test with .isNameParseable()]
 </remarks>
</member><member name="M:mapaction.datanames.api.AbstractDataName.changePermissionsClause(System.String)">
	<summary>
 A convenance function, to subsutute the Permissions clause of the current name with a new value.
 </summary>
	<param name="strNewPermissions">The new, subsutute Permissions clause</param>
	<remarks>
 A convenance function, to subsutute the Permissions clause of the current name with a new value.
 The new value does not need to be valid in the sense of the data naming convention, but must
 be valid in terms of the underlying storage.
 
 If the Permissions clause is not already present it will be inserted and the relevant undersources
 will be inserted. To completely remove an existing Permissions clause set newPermissionsClause=""
 and the relevant undersorces will be removed.
 
 Throws an RenamingDataException if the IDataName is either un-renamable [test with 
 .isRenameable()] or is not syntaticatally correct [test with .isNameParseable()]
 </remarks>
</member><member name="M:mapaction.datanames.api.AbstractDataName.changeFreeTextClause(System.String)">
	<summary>
 A convenance function, to subsutute the FreeText clause of the current name with a new value.
 </summary>
	<param name="strNewFreeText">The new, subsutute FreeText clause</param>
	<remarks>
 A convenance function, to subsutute the FreeText clause of the current name with a new value.
 The new value does not need to be valid in the sense of the data naming convention, but must
 be valid in terms of the underlying storage.
 
 If the FreeText clause is not already present it will be inserted and the relevant undersources
 will be inserted. To completely remove an existing FreeText clause set newFreeTextClause="" and
 the relevant undersorces will be removed.
 
 Throws an RenamingDataException if the IDataName is either un-renamable [test with 
 .isRenameable()] or is not syntaticatally correct [test with .isNameParseable()]
 </remarks>
</member><member name="M:mapaction.datanames.api.AbstractDataName.generateNameWithReplacedClause(System.String,System.String)">
	<summary>
 The method does NOT alter the underlying DataName - for that use the rename function. This function is 
 a helper function to help generate new strings, preparing the arguments for the rename function.
 </summary>
	<param name="strNewClauseValue"></param>
	<param name="strClauseName"></param>
	<returns>A String with the strNewClauseValue substituded in the appropriate places</returns>
	<remarks>
 The method does NOT alter the underlying DataName - for that use the rename function. This function is 
 a helper function to help generate new strings, preparing the arguments for the rename function.
 
 If the strClauseName is for a optional clause that is currently not included it will be inserted into the string.
 If the strClauseName is for a clause that is already present then the old clause will be replaced.
 If the strClauseName is for a optional clause and the strNewClauseValue is equal to Nothing or String.Empty
 then the optional clause will be removed.
 </remarks>
</member><member name="M:mapaction.datanames.api.AbstractDataName.getClauseIndex(System.String)">
	<summary>
 Returns a ZERO based index of the named clause for the current IDataName, accounting for 
 the presents or not of the various optional clauses. Will throw an InvalidDataNameException
 if the bitSum indicates that the name is not parseable.
 </summary>
	<param name="strClauseName">The name of the name cluase, normally passed using one of the
 constants with the "CLAUSE_" prefix.
 </param>
	<returns>A ZERO based index of the named clause for the current IDataName, accounting for 
 the presents or not of the various optional clauses. The return value of this method is
 designed to be a suitable argument for an array of strings generated by 
 Strings.Split(m_strName, "_"). If optional clause is not present, the value "-1" will
 be returned.
 </returns>
	<remarks>
 Returns a ZERO based index of the named clause for the current IDataName, accounting for 
 the presents or not of the various optional clauses. Will throw an InvalidDataNameException
 if the bitSum indicates that the name is not parseable.
 
 The return value of this method is designed to be a suitable argument for an array of
 strings generated by Strings.Split(m_strName, "_")
 
 If optional clause is not present, the value "-1" will be returned. The caller is responsible
 for checking of a "-1" value prior to passing it to an array.
 </remarks>
</member><member name="M:mapaction.datanames.api.AbstractDataName.getNameSyntaxStatus(System.String)">
	<summary>
 This method checks the syntax of the name in the string. If the name is parsable then the
 getNameValidityStatus() is also called and its results incorporated to give full information
 about the status of the name.
 </summary>
	<param name="strTestName">A string representing the string to be tested.</param>
	<returns>A Long which is the sum of the dnNameStatus emnumeration members.</returns>
	<remarks>
 This method checks the syntax of the name in the string. If the name is parsable then the
 getNameValidityStatus() is also called and its results incorporated to give full information
 about the status of the name.
 
 Implenemtnation note: This method requires that the name for testing is passed as a string 
 even though it is testing it self. This is to allow the method to be called recurvisly with
 variations on the name (eg substitutin underscourse for hyphens).
 </remarks>
</member><member name="M:mapaction.datanames.api.AbstractDataName.getNameValidityStatus(System.Collections.Generic.List{System.String}@,System.String)">
	<summary>
 This method tests whether or not each of the individual clauses in a parsable data name are
 contained in the relevant Data Name Clause Lookup tables.
 </summary>
	<param name="lstCurNameParts">An ordered list of some of the clauses of a data name.</param>
	<param name="strClauseName">The name of the next clause to test (ie the clause postition zero).
 Defaults to "Geoextent" ie the first clause of the data name.</param>
	<returns>A Long which is the sum of the dnNameStatus emnumeration members. Only those emumerations
 with the prefix INVALID, WARN, or INFO will be included.</returns>
	<remarks>
 This method tests whether or not each of the individual clauses in a parsable data name are
 contained in the relevant Data Name Clause Lookup tables.
 
 Implenmentation note: The lstCurNameParts parameter is passed ByRef. The implenmentation
 will consume the List object, removing elements from it as the metod recuses. Therefore the
 caller should not expect to be able to use the object passed to this parameter after this
 method has been called. If for any reason the caller still requires this object they should
 copy it before calling this method.
 
 Implenemtnation note: This method requires that the name for testing is passed as a string 
 even though it is testing it self. This is to allow the method to be called recurvisly with
 variations on the name.
 </remarks>
</member><member name="T:mapaction.datanames.api.AbstractDataName">
	<summary>
 Provides a framework for the implenmentation of the IDataName interface.
 </summary>
	<remarks>
 Provides a framework for the implenmentation of the IDataName interface.
 </remarks>
</member><member name="M:mapaction.datanames.api.AbstractDataNameClauseLookup.initialiseAllTables">
	<summary>
 Opens each of the dataname clause lookup tables. Must be called from the constructor
 </summary>
	<remarks>
 Opens each of the dataname clause lookup tables. Must be called from the constructor
 
 Uses the subclasses implenmentation of the openTable() method.
 </remarks>
</member><member name="M:mapaction.datanames.api.AbstractDataNameClauseLookup.openTable(System.String)">
	<summary>
 This method provides an implenmention specific means to open an individual flat table
 from a data source (eg, Access DB, ESRI GDB, XML files etc).
 </summary>
	<param name="strTableName">The name of the table to open. This should normally be passed
 using one of the API constants with the prefix "TABLENAME_"</param>
	<returns>A DataTable object representing the </returns>
	<remarks>
 This method provides an implenmention specific means to open an individual flat table
 from a data source (eg, Access DB, ESRI GDB, XML files etc).
 </remarks>
</member><member name="M:mapaction.datanames.api.AbstractDataNameClauseLookup.getDetails">
	<summary>
 Returns a string describing the storage location of the dataname clause tables.
 </summary>
	<returns>A string describing the storage location of the dataname clause tables.</returns>
	<remarks>
 Returns a string describing the storage location of the dataname clause tables.
 
 This may be the operating system file path if appropriate or a RDMS connection
 string, or a URL etc.
 </remarks>
</member><member name="M:mapaction.datanames.api.AbstractDataNameClauseLookup.getPath">
	<summary>
 Returns the operating system file path to the container of the dataname clause tables.
 </summary>
	<returns>A FileInfo object representing the operating system file path to the container 
 of the dataname clause tables.</returns>
	<remarks>
 Returns the operating system file path to the container of the dataname clause tables.
 
 If the location of these tables cannot represented as an operating system file (eg if they 
 are located in a RDBMS) then the Nothing object is returned.
 </remarks>
</member><member name="M:mapaction.datanames.api.AbstractDataNameClauseLookup.doDataColumnsMatch(System.Collections.ArrayList@,System.Collections.ArrayList@)">
	<summary>
 Compared two ArrayLists of DataColumn objects, to confirm whether or not the specfication
 of the columns (ie the schema) is identical for both.
 </summary>
	<param name="aryl1">An ArrayList of DataColumn objects</param>
	<param name="aryl2">An ArrayList of DataColumn objects</param>
	<returns>TRUE = the DataColumn specfications match. If the DataColumn specfications
 do not match then a LookupTableException is thrown.</returns>
	<remarks>
 Compared two ArrayLists of DataColumn objects, to confirm whether or not the specfication
 of the columns (ie the schema) is identical for both. This is used to verify the schema of
 any Data Name Clause Lookup Tables that have been opened.
 
 Is this really the best way to check the schema of the DB? probably could be done better using the XML schema definition stuff in ADO.NET
 Columns *must* be in the same order.
 </remarks>
</member><member name="M:mapaction.datanames.api.AbstractDataNameClauseLookup.getListFromTable(System.Data.DataTable@)">
	<summary>
 A convenience function to extact all of the clauses (ie the Primary Keys) from a
 Data Name Clause Lookup Table.
 </summary>
	<param name="dt">A DataTable representing the a Data Name Clause Lookup
 Table. An Exception will occur if the table does not have a primary column with a
 name which matches the PRI_KEY_COL_NAME constant.</param>
	<returns>A List(Of String) of each of the clauses in the DataTable</returns>
	<remarks>
 A convenience function to extact all of the clauses (ie the Primary Keys) from a
 Data Name Clause Lookup Table.
 
 An Exception will occur if the table does not have a primary column with a
 name which matches the PRI_KEY_COL_NAME constant.
 </remarks>
</member><member name="M:mapaction.datanames.api.AbstractDataNameClauseLookup.isStrInPriKeyCol(System.String@,System.Data.DataTable@)">
	<summary>
 Checks whether a particular test String is listed in the primary key column of the 
 DataTable. All strings are converted to lower case before comparision.
 </summary>
	<param name="strTestparam">The test String</param>
	<param name="dt">A DataTable representing a Data Name Lookup Table</param>
	<returns>TRUE = The test string is present in the primary key column of the 
 DataTable, FALSE otherwise.</returns>
	<remarks>
 Checks whether a particular test String is listed in the primary key column of the 
 DataTable. All strings are converted to lower case before comparision.
 
 This method is at the core of checking that the Data Name is valid.
 </remarks>
</member><member name="M:mapaction.datanames.api.AbstractDataNameClauseLookup.getDataCategoryList">
	<summary>
 A convenience function to extact all of the Data Category clauses as a List(Of Strings).
 </summary>
	<returns>A List(Of Strings) of all the valid Data Category clauses.
 </returns>
	<remarks>
 A convenience function to extact all of the Data Category clauses as a List(Of Strings).
 </remarks>
</member><member name="M:mapaction.datanames.api.AbstractDataNameClauseLookup.getDataCategoryTable">
	<summary>
 A convenience function to return the Data Category clauses lookup table, including all columns
 </summary>
	<returns>A DataTable representing the Data Category clauses lookup table.
 </returns>
	<remarks>
 A convenience function to return the Data Category clauses lookup table, including all columns
 </remarks>
</member><member name="M:mapaction.datanames.api.AbstractDataNameClauseLookup.getDataThemeList">
	<summary>
 A convenience function to extact all of the Data Theme clauses as a List(Of Strings).
 </summary>
	<returns>A List(Of Strings) of all the valid Data Theme clauses.
 </returns>
	<remarks>
 A convenience function to extact all of the Data Theme clauses as a List(Of Strings).
 </remarks>
</member><member name="M:mapaction.datanames.api.AbstractDataNameClauseLookup.getDataThemeTable">
	<summary>
 A convenience function to return the Data Theme clauses lookup table, including all columns
 </summary>
	<returns>A DataTable representing the Data Theme clauses lookup table.
 </returns>
	<remarks>
 A convenience function to return the Data Theme clauses lookup table, including all columns
 </remarks>
</member><member name="M:mapaction.datanames.api.AbstractDataNameClauseLookup.getDataTypeList">
	<summary>
 A convenience function to extact all of the Data Type clauses as a List(Of Strings).
 </summary>
	<returns>A List(Of Strings) of all the valid Data Type clauses.
 </returns>
	<remarks>
 A convenience function to extact all of the Data Type clauses as a List(Of Strings).
 </remarks>
</member><member name="M:mapaction.datanames.api.AbstractDataNameClauseLookup.getDataTypeTable">
	<summary>
 A convenience function to return the Data Type clauses lookup table, including all columns
 </summary>
	<returns>A DataTable representing the Data Type clauses lookup table.
 </returns>
	<remarks>
 A convenience function to return the Data Type clauses lookup table, including all columns
 </remarks>
</member><member name="M:mapaction.datanames.api.AbstractDataNameClauseLookup.getGeoExtentList">
	<summary>
 A convenience function to extact all of the GeoExtent clauses as a List(Of Strings).
 </summary>
	<returns>A List(Of Strings) of all the valid GeoExtent clauses.
 </returns>
	<remarks>
 A convenience function to extact all of the GeoExtent clauses as a List(Of Strings).
 </remarks>
</member><member name="M:mapaction.datanames.api.AbstractDataNameClauseLookup.getGeoExtentTable">
	<summary>
 A convenience function to return the GeoExtent clauses lookup table, including all columns
 </summary>
	<returns>A DataTable representing the GeoExtent clauses lookup table.
 </returns>
	<remarks>
 A convenience function to return the GeoExtent clauses lookup table, including all columns
 </remarks>
</member><member name="M:mapaction.datanames.api.AbstractDataNameClauseLookup.getPermissionsList">
	<summary>
 A convenience function to extact all of the Permissions clauses as a List(Of Strings).
 </summary>
	<returns>A List(Of Strings) of all the valid Permissions clauses.
 </returns>
	<remarks>
 A convenience function to extact all of the Permissions clauses as a List(Of Strings).
 </remarks>
</member><member name="M:mapaction.datanames.api.AbstractDataNameClauseLookup.getPermissionsTable">
	<summary>
 A convenience function to return the Permissions clauses lookup table, including all columns
 </summary>
	<returns>A DataTable representing the Permissions clauses lookup table.
 </returns>
	<remarks>
 A convenience function to return the Permissions clauses lookup table, including all columns
 </remarks>
</member><member name="M:mapaction.datanames.api.AbstractDataNameClauseLookup.getScaleCodesList">
	<summary>
 A convenience function to extact all of the Scale clauses as a List(Of Strings).
 </summary>
	<returns>A List(Of Strings) of all the valid Scale clauses.
 </returns>
	<remarks>
 A convenience function to extact all of the Scale clauses as a List(Of Strings).
 </remarks>
</member><member name="M:mapaction.datanames.api.AbstractDataNameClauseLookup.getScaleCodesTable">
	<summary>
 A convenience function to return the Scale clauses lookup table, including all columns
 </summary>
	<returns>A DataTable representing the Scale clauses lookup table.
 </returns>
	<remarks>
 A convenience function to return the Scale clauses lookup table, including all columns
 </remarks>
</member><member name="M:mapaction.datanames.api.AbstractDataNameClauseLookup.getSourceCodesList">
	<summary>
 A convenience function to extact all of the Source clauses as a List(Of Strings).
 </summary>
	<returns>A List(Of Strings) of all the valid Source clauses.
 </returns>
	<remarks>
 A convenience function to extact all of the Source clauses as a List(Of Strings).
 </remarks>
</member><member name="M:mapaction.datanames.api.AbstractDataNameClauseLookup.getSourceCodesTable">
	<summary>
 A convenience function to return the Source clauses lookup table, including all columns
 </summary>
	<returns>A DataTable representing the Source clauses lookup table.
 </returns>
	<remarks>
 A convenience function to return the Source clauses lookup table, including all columns
 </remarks>
</member><member name="M:mapaction.datanames.api.AbstractDataNameClauseLookup.isValidDataCategoryClause(System.String)">
	<summary>
 Checks whether a particular test String is a valid Data Category Clause.
 The strings are converted to lower case before comparision.
 </summary>
	<param name="strTestDataCatClause">The test String</param>
	<returns>TRUE = The test string if the test string is a valid Data Category Clause,
 FALSE otherwise.</returns>
	<remarks>
 Checks whether a particular test String is a valid Data Category Clause.
 The strings are converted to lower case before comparision.
 </remarks>
</member><member name="M:mapaction.datanames.api.AbstractDataNameClauseLookup.isValidDataThemeClause(System.String,System.String)">
	<summary>
 Checks whether a particular test String is a valid Data Theme Clause. Because
 Data Themes are nested within Data Categories, it is also necessary to pass the 
 Data Category to this method. The strings are converted to lower case before
 comparision.
 </summary>
	<param name="strTestDataThemeClause">The Data Theme Clause test String</param>
	<param name="strTestDataCatClause">The Data Category Clause test String</param>
	<returns>TRUE = The test string if the test string is a valid Data Theme Clause,
 FALSE otherwise.</returns>
	<remarks>
 Checks whether a particular test String is a valid Data Theme Clause. Because
 Data Themes are nested within Data Categories, it is also necessary to pass the 
 Data Category to this method. The strings are converted to lower case before
 comparision.
 </remarks>
</member><member name="M:mapaction.datanames.api.AbstractDataNameClauseLookup.isValidDataTypeClause(System.String)">
	<summary>
 Checks whether a particular test String is a valid Data Type Clause.
 The strings are converted to lower case before comparision.
 </summary>
	<param name="strTestDataTypeClause">The test String</param>
	<returns>TRUE = The test string if the test string is a valid Data Type Clause,
 FALSE otherwise.</returns>
	<remarks>
 Checks whether a particular test String is a valid Data Type Clause.
 The strings are converted to lower case before comparision.
 </remarks>
</member><member name="M:mapaction.datanames.api.AbstractDataNameClauseLookup.isValidGeoextentClause(System.String)">
	<summary>
 Checks whether a particular test String is a valid Geoextent Clause.
 The strings are converted to lower case before comparision.
 </summary>
	<param name="strTestGeoExtentClause">The test String</param>
	<returns>TRUE = The test string if the test string is a valid Geoextent Clause,
 FALSE otherwise.</returns>
	<remarks>
 Checks whether a particular test String is a valid Geoextent Clause.
 The strings are converted to lower case before comparision.
 </remarks>
</member><member name="M:mapaction.datanames.api.AbstractDataNameClauseLookup.isValidPermissionsClause(System.String)">
	<summary>
 Checks whether a particular test String is a valid Permissions Clause.
 The strings are converted to lower case before comparision.
 </summary>
	<param name="strTestPermissionsClause">The test String</param>
	<returns>TRUE = The test string if the test string is a valid Permissions Clause,
 FALSE otherwise.</returns>
	<remarks>
 Checks whether a particular test String is a valid Permissions Clause.
 The strings are converted to lower case before comparision.
 </remarks>
</member><member name="M:mapaction.datanames.api.AbstractDataNameClauseLookup.isValidScaleClause(System.String)">
	<summary>
 Checks whether a particular test String is a valid Scale Clause.
 The strings are converted to lower case before comparision.
 </summary>
	<param name="strTestScaleClause">The test String</param>
	<returns>TRUE = The test string if the test string is a valid Scale Clause,
 FALSE otherwise.</returns>
	<remarks>
 Checks whether a particular test String is a valid Scale Clause.
 The strings are converted to lower case before comparision.
 </remarks>
</member><member name="M:mapaction.datanames.api.AbstractDataNameClauseLookup.isValidSourceClause(System.String)">
	<summary>
 Checks whether a particular test String is a valid Source Clause.
 The strings are converted to lower case before comparision.
 </summary>
	<param name="strTestSourceClause">The test String</param>
	<returns>TRUE = The test string if the test string is a valid Source Clause,
 FALSE otherwise.</returns>
	<remarks>
 Checks whether a particular test String is a valid Source Clause.
 The strings are converted to lower case before comparision.
 </remarks>
</member><member name="T:mapaction.datanames.api.AbstractDataNameClauseLookup">
	<summary>
 Provides a framework for the implenmentation of the IDataNameClauseLookup interface.
 </summary>
	<remarks>
 Provides a framework for the implenmentation of the IDataNameClauseLookup interface.
 
 Subclasses must call initialiseAllTables() from within their constructor.
 To implement subclasses two methods, openTable() and getDetails() must be implenmented.
 </remarks>
</member><member name="M:mapaction.datanames.api.IDataListConnection.getDataListConnectionType">
	<summary>
 Returns an dnListType enumeration which represents the underlying
 physical type of the connection.
 </summary>
	<returns>an dnListType enumeration which represents the underlying
 physical type of the connection</returns>
	<remarks>
 Returns an dnListType enumeration which represents the underlying
 physical type of the connection.
 </remarks>
</member><member name="M:mapaction.datanames.api.IDataListConnection.getDataListConnectionTypeDesc">
	<summary>
 Returns a String which describes the type of connection.
 </summary>
	<returns>A String which describes the type of connection.</returns>
	<remarks>
 Returns a String which describes the type of connection.
 </remarks>
</member><member name="M:mapaction.datanames.api.IDataListConnection.getDetails">
	<summary>
 Returns a string describing the type of DataListConnection.
 </summary>
	<returns>A string describing the type of DataListConnection.</returns>
	<remarks>
 Returns a string describing the type of DataListConnection.
 
 This may take on of a number of forms:
 * An operating system directory path, for a directory containing shapefiles
 * An operating system file path for a Personal GDB, MXD or connection file.
 * A RDMS connection string, 
 * A URL
 * etc.
 </remarks>
</member><member name="M:mapaction.datanames.api.IDataListConnection.getPath">
	<summary>
 Returns the operating system file path to the DataListConnection.
 </summary>
	<returns>A FileInfo object representing the operating system file path
 to the DataListConnection.</returns>
	<remarks>
 Returns the operating system file path to the DataListConnection.
 
 If the location of the DataListConnection cannot represented as an 
 operating system file (eg if they are located in a RDBMS) then the 
 Nothing object is returned.
 </remarks>
</member><member name="M:mapaction.datanames.api.IDataListConnection.getLayerNamesStrings">
	<summary>
 Returns a List of strings representing the names of all of the layers defined
 by this DataListConnection. 
 </summary>
	<returns>
 List of strings representing the names of all of the layers defined
 by this DataListConnection.
 </returns>
	<remarks>
 Returns a List of strings representing the names of all of the layers defined
 by this DataListConnection. 
 </remarks>
</member><member name="M:mapaction.datanames.api.IDataListConnection.getLayerDataNamesList">
	<summary>
 Returns a List of IDataName objects representing the names of all of the layers defined
 by this DataListConnection. 
 </summary>
	<returns>Returns a List of IDataName objects representing the names of all of the layers defined
 by this GeoDataListConnection.</returns>
	<remarks>
 Returns a List of IDataName objects representing the names of all of the layers defined
 by this GeoDataListConnection.
 
 This function is a shorthand for getLayerDataNamesList(getDefaultDataNameClauseLookup()) 
 The result of the getDefaultDataNameClauseLookup() function is passed to the constructor of
 the IDataName objects. If a different DataNameClauseLookup object should be used then use the
 overloaded alternative form of this function.
 </remarks>
</member><member name="M:mapaction.datanames.api.IDataListConnection.getLayerDataNamesList(mapaction.datanames.api.IDataNameClauseLookup@)">
	<summary>
 Returns a List of IDataName objects representing the names of all of the layers defined
 by this DataListConnection. 
 </summary>
	<param name="dnclUserSelected">
 IDataNameClauseLookup object. This is passed to the constructor of
 the IDataName objects
 </param>
	<returns>A List of IDataName objects representing the names of all of the layers defined
 by this DataListConnection.</returns>
	<remarks>
 Returns a List of IDataName objects representing the names of all of the layers defined
 by this DataListConnection.
 
 The IDataNameClauseLookup object is explictly assigned and this is passed to the constructor of
 the IDataName objects. If the default DataNameClauseLookup object is sufficent then the alternative
 shorthand function can be used.
 </remarks>
</member><member name="M:mapaction.datanames.api.IDataListConnection.doesLayerExist(System.String)">
	<summary>
 A convenience function to test whether or not the named layer is present in this DataListConnection.
 </summary>
	<param name="strLayerName">The name of the layer, whose presense is being tested for.</param>
	<returns>TRUE if strLayerName is present in this DataListConnection, FALSE otherwise</returns>
	<remarks>
 A convenience function to test whether or not the named layer is present in this DataListConnection.
 </remarks>
</member><member name="M:mapaction.datanames.api.IDataListConnection.getDefaultDataNameClauseLookup">
	<summary>
 The IDataListConnection should attempt to physically locate the DataNames Clause Tables either
 on the filesystem or in the GDB as apropriate. It should then return an IDataNameClauseLookup object
 as appropriate. The search method to find the DataNames Clause Tables is relevative to the location of the 
 IDataListConnection
 
 If the Data Names Clause Tables cannot be physically located becuase either they do not exist or there
 is not a uquine location (eg in the case of a MXD), then a exception is raised.
 </summary>
	<returns>An IDataNameClauseLooup object representing automatically located DataNames Clause Tables</returns>
	<remarks>
 The IDataListConnection should attempt to physically locate the DataNames Clause Tables either
 on the filesystem or in the GDB as apropriate. It should then return an IDataNameClauseLookup object
 as appropriate. The search method to find the DataNames Clause Tables is relevative to the location of the 
 IDataListConnection.
 
 If the Data Names Clause Tables cannot be physically located becuase either they do not exist or there
 is not a uquine location (eg in the case of a MXD), then a exception is raised.
 
 For more details on how this should be implenmented please see:
 http://code.google.com/p/mapaction-toolbox/wiki/SearchForDefaultDataNameClauseLookupTables
 </remarks>
</member><member name="M:mapaction.datanames.api.IDataListConnection.isHeirachical">
	<summary>
 Does the IDataListConnection represents some from of heirachical list of data?
 </summary>
	<returns>
 TRUE = the IDataListConnection has a heirachical structure.
 FALSE = the IDataListConnection does not have a heirachical structure.
 </returns>
	<remarks>
 Does the IDataListConnection represents some from of heirachical list of data?
 
 Some implenmentation of the IDataListConnection, will represents some from of heirachical list of data
 (eg a directory full of subdirectories and shapefiles). The value returned by this method represents
 whether or not the underlying list of data is heirachical.
 
 The implenmentor is free to interperate the meaning of heirachicalin the manner deemed most appropriate 
 for the particular type of IDataListConnection.
 
 For example. Most end users will have a clear expectation that this would be TRUE for a 
 filesystem directory. 
 
 Strictly an MXD is a heirachical list of layer, with the top level of the heirachy declared as DataFrames 
 and lower levels declared as potenially nested Group Layers. However MXDs are typically such shallow heirachies
 that enforcing a heirachical search of an MXD may confuse more users than it helps. In such curcumstances 
 the implenmentor may choose to return FALSE here and flatten the MXD automatically.
 </remarks>
</member><member name="M:mapaction.datanames.api.IDataListConnection.setRecuse(System.Boolean)">
	<summary>
 If the IDataListConnection, represents some from of heirachical list of data (eg a directory
 full of subdirectories and shapefiles), this method sets whether or not the IDataListConnection should recuse
 the subdirectories.
 </summary>
	<param name="blnRecuse">TRUE = the heirachy should be recused. FALSE = the heirachy should not be recused.</param>
	<remarks>
 If the IDataListConnection, represents some from of heirachical list of data (eg a directory
 full of subdirectories and shapefiles), this method sets whether or not the IDataListConnection should recuse
 the subdirectories when either of the methods getLayerNamesStrings() or getLayerDataNamesList() are called.
 </remarks>
</member><member name="M:mapaction.datanames.api.IDataListConnection.getRecuse">
	<summary>
 Gets the current setting of whether or not heirachical lists should be recused.
 </summary>
	<returns>TRUE = the heirachy should be recused. FALSE = the heirachy should not be recused.</returns>
	<remarks>Gets the current setting of whether or not heirachical lists should be recused.</remarks>
</member><member name="T:mapaction.datanames.api.IDataListConnection">
	<summary>
 Classes implementing this interface represent a logical group of layers. They may be stored
 in one location (eg. GDB or directory of shapefiles) or they may be used together in some
 other logical manner (eg. in a map MXD).
 </summary>
	<remarks>
 Classes implementing this interface represent a logical group of layers. They may be stored
 in one location (eg. GDB or directory of shapefiles) or they may be used together in some
 other logical manner (eg. in a map MXD).
 
 This interface is generally used along with two others, IDataNameClauseLookup and IDataName
 </remarks>
</member><member name="P:mapaction.datanames.api.My.Resources.Resources.ResourceManager">
	<summary>
  Returns the cached ResourceManager instance used by this class.
</summary>
</member><member name="P:mapaction.datanames.api.My.Resources.Resources.Culture">
	<summary>
  Overrides the current thread's CurrentUICulture property for all
  resource lookups using this strongly typed resource class.
</summary>
</member><member name="T:mapaction.datanames.api.My.Resources.Resources">
	<summary>
  A strongly-typed resource class, for looking up localized strings, etc.
</summary>
</member><member name="M:mapaction.datanames.api.IDataNameClauseLookup.isValidGeoextentClause(System.String)">
	<summary>
 Tests whether the testGeoExtentClause is listed in the datanaming_clause_geoextent table.
 </summary>
	<param name="testGeoExtentClause">The test clause</param>
	<returns>TRUE if the testGeoExtentClause is found in the relevant table, FALSE otherwise.</returns>
	<remarks>
 Tests whether the testGeoExtentClause is listed in the datanaming_clause_geoextent table.
 </remarks>
</member><member name="M:mapaction.datanames.api.IDataNameClauseLookup.isValidDataCategoryClause(System.String)">
	<summary>
 Tests whether the testDataCatClause is listed in the datanaming_clause_data_categories table.
 </summary>
	<param name="testDataCatClause">The test clause</param>
	<returns>TRUE if the testDataCatClause is found in the relevant table, FALSE otherwise.</returns>
	<remarks>
 Tests whether the testDataCatClause is listed in the datanaming_clause_data_categories table.
 </remarks>
</member><member name="M:mapaction.datanames.api.IDataNameClauseLookup.isValidDataThemeClause(System.String,System.String)">
	<summary>
 Tests whether the testDataThemeClause is listed in the datanaming_clause_data_theme table.
 </summary>
	<param name="testDataThemeClause">The test clause</param>
	<returns>TRUE if the testDataThemeClause is found in the relevant table, FALSE otherwise.</returns>
	<remarks>
 Tests whether the testDataThemeClause is listed in the datanaming_clause_data_theme table.
 </remarks>
</member><member name="M:mapaction.datanames.api.IDataNameClauseLookup.isValidDataTypeClause(System.String)">
	<summary>
 Tests whether the testDataTypeClause is listed in the datanaming_clause_data_type table.
 </summary>
	<param name="testDataTypeClause">The test clause</param>
	<returns>TRUE if the testDataTypeClause is found in the relevant table, FALSE otherwise.</returns>
	<remarks>
 Tests whether the testDataTypeClause is listed in the datanaming_clause_data_type table.
 
 Note that this does NOT test whether or not the testDataTypeClause matches the data type 
 of a particular layer. For that see .....
 </remarks>
</member><member name="M:mapaction.datanames.api.IDataNameClauseLookup.isValidScaleClause(System.String)">
	<summary>
 Tests whether the testScaleClause is listed in the datanaming_clause_scale table.
 </summary>
	<param name="testScaleClause">The test clause</param>
	<returns>TRUE if the testScaleClause is found in the relevant table, FALSE otherwise.</returns>
	<remarks>
 Tests whether the testScaleClause is listed in the datanaming_clause_scale table.
 </remarks>
</member><member name="M:mapaction.datanames.api.IDataNameClauseLookup.isValidSourceClause(System.String)">
	<summary>
 Tests whether the testSourceClause is listed in the datanaming_clause_source table.
 </summary>
	<param name="testSourceClause">The test clause</param>
	<returns>TRUE if the testSourceClause is found in the relevant table, FALSE otherwise.</returns>
	<remarks>
 Tests whether the testSourceClause is listed in the datanaming_clause_source table.
 </remarks>
</member><member name="M:mapaction.datanames.api.IDataNameClauseLookup.isValidPermissionsClause(System.String)">
	<summary>
 Tests whether the testPermissionsClause is listed in the datanaming_clause_permission table.
 </summary>
	<param name="testPermissionsClause">The test clause</param>
	<returns>TRUE if the testPermissionsClause is found in the relevant table, FALSE otherwise.</returns>
	<remarks>
 Tests whether the testPermissionsClause is listed in the datanaming_clause_permission table.
 </remarks>
</member><member name="M:mapaction.datanames.api.IDataNameClauseLookup.getGeoExtentList">
	<summary>
 This method returns a simple list of all of the valid GeoExtent clauses, as Strings, from the
 datanaming_clause_geoextent table.
 </summary>
	<returns>A list of clauses as Strings, without any extra information.</returns>
	<remarks>
 This method returns a simple list of all of the valid GeoExtent clauses, as Strings, from the
 datanaming_clause_geoextent table.
 </remarks>
</member><member name="M:mapaction.datanames.api.IDataNameClauseLookup.getDataCategoryList">
	<summary>
 This method returns a simple list of all of the valid GeoExtent clauses, as Strings, from the
 datanaming_clause_data_categories table.
 </summary>
	<returns>A list of clauses as Strings, without any extra information.</returns>
	<remarks>
 This method returns a simple list of all of the valid GeoExtent clauses, as Strings, from the
 datanaming_clause_data_categories table.
 </remarks>
</member><member name="M:mapaction.datanames.api.IDataNameClauseLookup.getDataThemeList">
	<summary>
 This method returns a simple list of all of the valid GeoExtent clauses, as Strings, from the
 datanaming_clause_data_theme table.
 </summary>
	<returns>A list of clauses as Strings, without any extra information.</returns>
	<remarks>
 This method returns a simple list of all of the valid GeoExtent clauses, as Strings, from the
 datanaming_clause_data_theme table.
 </remarks>
</member><member name="M:mapaction.datanames.api.IDataNameClauseLookup.getDataTypeList">
	<summary>
 This method returns a simple list of all of the valid GeoExtent clauses, as Strings, from the
 datanaming_clause_data_type table.
 </summary>
	<returns>A list of clauses as Strings, without any extra information.</returns>
	<remarks>
 This method returns a simple list of all of the valid GeoExtent clauses, as Strings, from the
 datanaming_clause_data_type table.
 </remarks>
</member><member name="M:mapaction.datanames.api.IDataNameClauseLookup.getScaleCodesList">
	<summary>
 This method returns a simple list of all of the valid GeoExtent clauses, as Strings, from the
 datanaming_clause_scale table.
 </summary>
	<returns>A list of clauses as Strings, without any extra information.</returns>
	<remarks>
 This method returns a simple list of all of the valid GeoExtent clauses, as Strings, from the
 datanaming_clause_scale table.
 </remarks>
</member><member name="M:mapaction.datanames.api.IDataNameClauseLookup.getSourceCodesList">
	<summary>
 This method returns a simple list of all of the valid GeoExtent clauses, as Strings, from the
 datanaming_clause_source table.
 </summary>
	<returns>A list of clauses as Strings, without any extra information.</returns>
	<remarks>
 This method returns a simple list of all of the valid GeoExtent clauses, as Strings, from the
 datanaming_clause_source table.
 </remarks>
</member><member name="M:mapaction.datanames.api.IDataNameClauseLookup.getPermissionsList">
	<summary>
 This method returns a simple list of all of the valid GeoExtent clauses, as Strings, from the
 datanaming_clause_permission table.
 </summary>
	<returns>A list of clauses as Strings, without any extra information.</returns>
	<remarks>
 This method returns a simple list of all of the valid GeoExtent clauses, as Strings, from the
 datanaming_clause_permission table.
 </remarks>
</member><member name="M:mapaction.datanames.api.IDataNameClauseLookup.getGeoExtentTable">
	<summary>
 This method returns a full bindable version of the datanaming_clause_geoextent table.
 </summary>
	<returns>A full bindable version of the datanaming_clause_geoextent table.</returns>
	<remarks>
 This method returns a full bindable version of the datanaming_clause_geoextent table.
 
 This includes the clause and description columns plus any other columns included in the 
 datanaming_clause_geoextent table.
 </remarks>
</member><member name="M:mapaction.datanames.api.IDataNameClauseLookup.getDataCategoryTable">
	<summary>
 This method returns a full bindable version of the datanaming_clause_data_categories table.
 </summary>
	<returns>A full bindable version of the datanaming_clause_data_categories table.</returns>
	<remarks>
 This method returns a full bindable version of the datanaming_clause_data_categories table.
 
 This includes the clause and description columns plus any other columns included in the 
 datanaming_clause_data_categories table.
 </remarks>
</member><member name="M:mapaction.datanames.api.IDataNameClauseLookup.getDataThemeTable">
	<summary>
 This method returns a full bindable version of the datanaming_clause_data_theme table.
 </summary>
	<returns>A full bindable version of the datanaming_clause_data_theme table.</returns>
	<remarks>
 This method returns a full bindable version of the datanaming_clause_data_theme table.
 
 This includes the clause and description columns plus any other columns included in the 
 datanaming_clause_data_theme table.
 </remarks>
</member><member name="M:mapaction.datanames.api.IDataNameClauseLookup.getDataTypeTable">
	<summary>
 This method returns a full bindable version of the datanaming_clause_data_type table.
 </summary>
	<returns>A full bindable version of the datanaming_clause_data_type table.</returns>
	<remarks>
 This method returns a full bindable version of the datanaming_clause_data_type table.
 
 This includes the clause and description columns plus any other columns included in the 
 datanaming_clause_data_type table.
 </remarks>
</member><member name="M:mapaction.datanames.api.IDataNameClauseLookup.getScaleCodesTable">
	<summary>
 This method returns a full bindable version of the datanaming_clause_scale table.
 </summary>
	<returns>A full bindable version of the datanaming_clause_scale table.</returns>
	<remarks>
 This method returns a full bindable version of the datanaming_clause_scale table.
 
 This includes the clause and description columns plus any other columns included in the 
 datanaming_clause_scale table.
 </remarks>
</member><member name="M:mapaction.datanames.api.IDataNameClauseLookup.getSourceCodesTable">
	<summary>
 This method returns a full bindable version of the datanaming_clause_source table.
 </summary>
	<returns>A full bindable version of the datanaming_clause_source table.</returns>
	<remarks>
 This method returns a full bindable version of the datanaming_clause_source table.
 
 This includes the clause and description columns plus any other columns included in the 
 datanaming_clause_source table.
 </remarks>
</member><member name="M:mapaction.datanames.api.IDataNameClauseLookup.getPermissionsTable">
	<summary>
 This method returns a full bindable version of the datanaming_clause_permission table.
 </summary>
	<returns>A full bindable version of the datanaming_clause_permission table.</returns>
	<remarks>
 This method returns a full bindable version of the datanaming_clause_permission table.
 
 This includes the clause and description columns plus any other columns included in the 
 datanaming_clause_permission table.
 </remarks>
</member><member name="M:mapaction.datanames.api.IDataNameClauseLookup.getDetails">
	<summary>
 Returns a string describing the storage location of the dataname clause tables.
 </summary>
	<returns>A string describing the storage location of the dataname clause tables.</returns>
	<remarks>
 Returns a string describing the storage location of the dataname clause tables.
 
 This may be the operating system file path if appropriate or a RDMS connection
 string, or a URL etc.
 </remarks>
</member><member name="M:mapaction.datanames.api.IDataNameClauseLookup.getPath">
	<summary>
 Returns the operating system file path to the container of the dataname clause tables.
 </summary>
	<returns>A FileInfo object representing the operating system file path to the container 
 of the dataname clause tables.</returns>
	<remarks>
 Returns the operating system file path to the container of the dataname clause tables.
 
 If the location of these tables cannot represented as an operating system file (eg if they 
 are located in a RDBMS) then the Nothing object is returned.
 </remarks>
</member><member name="T:mapaction.datanames.api.IDataNameClauseLookup">
	<summary>
 Classes implementing this interface provide a means to interact with a collection of flat database
 tables, which collectively, list valid values for each individual clause in a data name.
 </summary>
	<remarks>
 Classes implementing this interface provide a means to interact with a collection of flat database
 tables, which collectively, list valid values for each individual clause in a data name.
 
 The names of the relevant tables are:
     "datanaming_clause_geoextent"
     "datanaming_clause_data_categories"
     "datanaming_clause_data_theme"
     "datanaming_clause_data_type"
     "datanaming_clause_scale"
     "datanaming_clause_source"
     "datanaming_clause_permission"
 (these are defined by the constants with the prefix "TABLENAME_")
 
 It is not expected that that will be any public constructors for classes implenementing IDataNameClauseLookup.
 In general, instances of IDataNameClauseLookup should be obtained either by use of the 
 IDataList.getDefaultDataNameClauseLookup() method or by using a correponding XXXX Factory class.
 </remarks>
</member><member name="M:mapaction.datanames.api.AbstractDataListConnection.#ctor(System.Boolean)">
	<summary>
 The Constructor.
 </summary>
	<param name="blnRecuse">The default Recusive behaviour, if there is a heirachircal 
 structure to the underlying DataList. TRUE = the heirachy should be recused.
 FALSE = the heirachy should not be recused.
 </param>
	<remarks>
 The Constructor. 
 
 The constructor is declared Protected to discourage implenmenters from
 making their constructors public. Use the related Factory class instead.
 </remarks>
</member><member name="M:mapaction.datanames.api.AbstractDataListConnection.#ctor">
	<summary>
 The Constructor. Sets default Recusive behaviour to TRUE.
 </summary>
	<remarks>
 The Constructor. Sets default Recusive behaviour to TRUE.
 
 The constructor is declared Protected to discourage implenmenters from
 making their constructors public. Use the related Factory class instead.
 </remarks>
</member><member name="T:mapaction.datanames.api.AbstractDataListConnection">
	<summary>
 Provides a framework for the implenmentation of the IDataListConnection interface.
 </summary>
	<remarks>
 Provides a framework for the implenmentation of the IDataListConnection interface.
 </remarks>
</member><member name="M:mapaction.datanames.api.IDataName.getNameStr">
	<summary>
 Returns the current IDataName as a String.
 </summary>
	<returns>a string of the current Data Name</returns>
	<remarks>
 Returns the current IDataName as a String. The returned name should not include
 (i) the path (ii) the filename extension (eg ".shp") (iii) the RDBMS database or
 RDBMS user name prefixes (eg "mapaction.sde.")
 </remarks>
</member><member name="M:mapaction.datanames.api.IDataName.getPathStr">
	<summary>
 Returns the path of the current IDataName as a String if possible. Should not
 include trailing slash or backslash.
 </summary>
	<returns>
 a string of the current Data Name's path. Or is a path is not available a null 
 or zero length string is returned.
 </returns>
	<remarks>
 Returns the path of the current Data Name as a String, if a suitable meaning of
 path is applicable. If there is no easy or meaningful sense of a path (eg for a 
 RDBMS) then a null or zero length string is returned.

 Should not include trailing slash or backslash.
</remarks>
</member><member name="M:mapaction.datanames.api.IDataName.getNameAndFullPathStr">
	<summary>
 Returns the fully qualified IDataName as a String if possible.
 </summary>
	<returns>
 a string of the current IDataName's the fully qualified name. Or is a path is not
 available then just the fully qualified name is returned (ie including the filename
 extension [eg ".shp"] the RDBMS database or RDBMS user name prefixes
 [eg "mapaction.sde."]
 </returns>
	<remarks>
 Returns getPathStr() + "\" + getNameStr()
 Returns the fully qualified IDataName as a String, if a suitable meaning of
 path is applicable. If there is no easy or meaningful sense of a path (eg for a 
 RDBMS) then the fully qualified name is returned (ie including the filename
 extension [eg ".shp"] the RDBMS database or RDBMS user name prefixes
 [eg "mapaction.sde."].
 </remarks>
</member><member name="M:mapaction.datanames.api.IDataName.checkNameStatus">
	<summary>
 This method does the core processing to determine whether or not the particular name represented by 
 this object is syntatically correct and valid or not.
 </summary>
	<returns>A Long which is the sum of the dnNameStatus emnumeration members</returns>
	<remarks>
 This method does the core processing to determine whether or not the particular name represented by 
 this object is syntatically correct and valid or not. 
 
 The status flags are a sum of the dnNameStatus emnumeration members and are arranged in four categories:
     INVALID = "One or more of the clauses (excluding Free Text) cannot be found in the Data Name Clause Lookup Tables
     SYNTAX_ERROR = "The format of the name cannot be understood. Individual clauses cannot be identified."
     WARN = "The name can be understood and the clauses are valid, but for some reason there is a risk that it will be misinterprited"
     INFO = "Other information about the name"
 
 All of the flags are prefixed with one of these four names. It is possible to test
 for all flags within a particular category by just testing agains the root. eg:
 
 ((myNameStatus And dnNameStatus.SYNTAX_ERROR) = dnNameStatus.SYNTAX_ERROR)
 
 will return true for SYNTAX_ERROR_CONTAINS_HYPHENS, SYNTAX_ERROR_TOO_FEW_CLAUSES,
 SYNTAX_ERROR_DOUBLE_UNDERSCORE and SYNTAX_ERROR_OTHER
 
 There is no "is valid" flag since depending on context this is any 
 combination of "not DATANAME_INVALID", "not DATANAME_SYNTAX_ERROR" 
 and maybe "not DATANAME_WARN"
 </remarks>
</member><member name="M:mapaction.datanames.api.IDataName.isNameParseable">
	<summary>
 Tests whether or not the IDataName is syntatically correct.
 </summary>
	<returns>Boolean. TRUE is the name is syntatically correct, FALSE otherwise</returns>
	<remarks>
 Tests whether or not the IDataName is syntatically correct.
 
 This method is shorthand for:
 (Not (checkNameStatus() And dnNameStatus.SYNTAX_ERROR) = dnNameStatus.SYNTAX_ERROR))
 </remarks>
</member><member name="M:mapaction.datanames.api.IDataName.isNameValid">
	<summary>
 Tests whether or not the Data Name is both syntatically correct and all of the clauses are found in the
 relevant IDataNameClauseLookupTables.
 </summary>
	<returns>
 Boolean. TRUE is the name is syntatically correct AND all of the clauses are found in the
 relevant IDataNameClauseLookupTables, FALSE otherwise
 </returns>
	<remarks>
 Tests whether or not the Data Name is both syntatically correct and all of the clauses are found in the
 relevant IDataNameClauseLookupTables. If optional clauses are present then their values must be found in
 the relevant  IDataNameClauseLookupTables.
 
 This method is shorthand for:
 (Not (checkNameStatus() And dnNameStatus.SYNTAX_ERROR) = dnNameStatus.SYNTAX_ERROR)) _
 and (Not (checkNameStatus() And dnNameStatus.INVALID) = dnNameStatus.INVALID))
 </remarks>
</member><member name="M:mapaction.datanames.api.IDataName.hasOptionalScaleClause">
	<summary>
 Does this name include the optional "Scale" clause in it?
 </summary>
	<returns>
 TRUE = The optional scale clause is present AND the name is syntatically correct.
 FALSE = The optional scale clause is not present OR the name is not syntatically correct.
 </returns>
	<remarks>Does this name include the optional "Scale" clause in it?</remarks>
</member><member name="M:mapaction.datanames.api.IDataName.hasOptionalPermissionClause">
	<summary>
 Does this name include the optional "Data Permissions" clause in it?
 </summary>
	<returns>
 TRUE = The optional Data Permissions clause is present AND the name is syntatically correct.
 FALSE = The optional Data Permissions clause is not present OR the name is not syntatically correct.
 </returns>
	<remarks>Does this name include the optional "Data Permissions" clause in it?</remarks>
</member><member name="M:mapaction.datanames.api.IDataName.hasOptionalFreeText">
	<summary>
 Does this IDataName include the optional "Free Text" clause?
 </summary>
	<returns>
 TRUE = The optional Free Text clause is present AND the name is syntatically correct.
 FALSE = The optional Free Text clause is not present OR the name is not syntatically correct.
 </returns>
	<remarks>Does this IDataName include the optional "Data Permissions" clause in it?</remarks>
</member><member name="M:mapaction.datanames.api.IDataName.isRenameable">
	<summary>
 Returns a runtime value for whether or not it is possible for the IDataName of this data layer 
 to be changed? For example this made be no if the underlying file system is readony, or 
 the data resides on a webservice such as WMS/WFS.
 </summary>
	<returns>
 TRUE = the name of the data layer can be changed.
 FALSE = the name of the data layer cannot be changed.
 </returns>
	<remarks>
 Returns a runtime value for whether or not it is possible for the IDataName of this data layer 
 to be changed? For example this may be FALSE if the underlying file system is readony, or 
 the data resides on a webservice such as WMS/WFS.
 </remarks>
</member><member name="M:mapaction.datanames.api.IDataName.rename(System.String)">
	<summary>
 Attempts to rename the IDataName, to the newNameStr. The newNameStr does not need to be valid
 in the sense of the data naming convention, but must be valid in terms of the underlying storage.
 </summary>
	<param name="newNameStr">The new Name for the IDataName.</param>
	<remarks>
 Attempts to rename the DataName, to the newNameStr. The newNameStr does not need to be valid
 in the sense of the data naming convention, but must be valid in terms of the underlying storage.
 
 If the renaming fails for any reason a RenamingDataException is thrown.
 </remarks>
</member><member name="M:mapaction.datanames.api.IDataName.changeGeoExtentClause(System.String)">
	<summary>
 A convenance function, to subsutute the GeoExtent clause of the current name with a new value.
 </summary>
	<param name="newGeoExtent">The new, subsutute GeoExtent clause</param>
	<remarks>
 A convenance function, to subsutute the GeoExtent clause of the current name with a new value.
 The new value does not need to be valid in the sense of the data naming convention, but must
 be valid in terms of the underlying storage.
 
 Throws an RenamingDataException if the IDataName is either un-renamable [test with 
 .isRenameable()] or is not syntaticatally correct [test with .isNameParseable()]
 </remarks>
</member><member name="M:mapaction.datanames.api.IDataName.changeDataCategoryClause(System.String)">
	<summary>
 A convenance function, to subsutute the DataCategory clause of the current name with a new value.
 </summary>
	<param name="newDataCategory">The new, subsutute DataCategory clause</param>
	<remarks>
 A convenance function, to subsutute the DataCategory clause of the current name with a new value.
 The new value does not need to be valid in the sense of the data naming convention, but must
 be valid in terms of the underlying storage.
 
 Throws an RenamingDataException if the IDataName is either un-renamable [test with 
 .isRenameable()] or is not syntaticatally correct [test with .isNameParseable()]
 </remarks>
</member><member name="M:mapaction.datanames.api.IDataName.changeDataThemeClause(System.String)">
	<summary>
 A convenance function, to subsutute the DataTheme clause of the current name with a new value.
 </summary>
	<param name="newDataTheme">The new, subsutute DataTheme clause</param>
	<remarks>
 A convenance function, to subsutute the DataTheme clause of the current name with a new value.
 The new value does not need to be valid in the sense of the data naming convention, but must
 be valid in terms of the underlying storage.
 
 Throws an RenamingDataException if the IDataName is either un-renamable [test with 
 .isRenameable()] or is not syntaticatally correct [test with .isNameParseable()]
 </remarks>
</member><member name="M:mapaction.datanames.api.IDataName.changeDataTypeClause(System.String)">
	<summary>
 A convenance function, to subsutute the DataType clause of the current name with a new value.
 </summary>
	<param name="newDataType">The new, subsutute DataType clause</param>
	<remarks>
 A convenance function, to subsutute the DataType clause of the current name with a new value.
 The new value does not need to be valid in the sense of the data naming convention, but must
 be valid in terms of the underlying storage.
 
 Throws an RenamingDataException if the IDataName is either un-renamable [test with 
 .isRenameable()] or is not syntaticatally correct [test with .isNameParseable()]
 </remarks>
</member><member name="M:mapaction.datanames.api.IDataName.changePermissionsClause(System.String)">
	<summary>
 A convenance function, to subsutute the Permissions clause of the current name with a new value.
 </summary>
	<param name="newPermissionsClause">The new, subsutute Permissions clause</param>
	<remarks>
 A convenance function, to subsutute the Permissions clause of the current name with a new value.
 The new value does not need to be valid in the sense of the data naming convention, but must
 be valid in terms of the underlying storage.
 
 If the Permissions clause is not already present it will be inserted and the relevant undersources
 will be inserted. To completely remove an existing Permissions clause set newPermissionsClause=""
 and the relevant undersorces will be removed.
 
 Throws an RenamingDataException if the IDataName is either un-renamable [test with 
 .isRenameable()] or is not syntaticatally correct [test with .isNameParseable()]
 </remarks>
</member><member name="M:mapaction.datanames.api.IDataName.changeScaleClause(System.String)">
	<summary>
 A convenance function, to subsutute the Scale clause of the current name with a new value.
 </summary>
	<param name="newScaleClause">The new, subsutute Scale clause</param>
	<remarks>
 A convenance function, to subsutute the Scale clause of the current name with a new value.
 The new value does not need to be valid in the sense of the data naming convention, but must
 be valid in terms of the underlying storage.
 
 If the Scale clause is not already present it will be inserted and the relevant undersources
 will be inserted. To completely remove an existing Scale clause set newScaleClause="" and
 the relevant undersorces will be removed.
 
 Throws an RenamingDataException if the IDataName is either un-renamable [test with 
 .isRenameable()] or is not syntaticatally correct [test with .isNameParseable()]
 </remarks>
</member><member name="M:mapaction.datanames.api.IDataName.changeSourceClause(System.String)">
	<summary>
 A convenance function, to subsutute the Source clause of the current name with a new value.
 </summary>
	<param name="newSourceClause">The new, subsutute Source clause</param>
	<remarks>
 A convenance function, to subsutute the Source clause of the current name with a new value.
 The new value does not need to be valid in the sense of the data naming convention, but must
 be valid in terms of the underlying storage.
 
 Throws an RenamingDataException if the IDataName is either un-renamable [test with 
 .isRenameable()] or is not syntaticatally correct [test with .isNameParseable()]
 </remarks>
</member><member name="M:mapaction.datanames.api.IDataName.changeFreeTextClause(System.String)">
	<summary>
 A convenance function, to subsutute the FreeText clause of the current name with a new value.
 </summary>
	<param name="newFreeTextClause">The new, subsutute FreeText clause</param>
	<remarks>
 A convenance function, to subsutute the FreeText clause of the current name with a new value.
 The new value does not need to be valid in the sense of the data naming convention, but must
 be valid in terms of the underlying storage.
 
 If the FreeText clause is not already present it will be inserted and the relevant undersources
 will be inserted. To completely remove an existing FreeText clause set newFreeTextClause="" and
 the relevant undersorces will be removed.
 
 Throws an RenamingDataException if the IDataName is either un-renamable [test with 
 .isRenameable()] or is not syntaticatally correct [test with .isNameParseable()]
 </remarks>
</member><member name="T:mapaction.datanames.api.IDataName">
	<summary>
 Classes implementing this interface represent the status of the name of an individual layer, table
 dataset or other file which is a part of a MapAction GIS data directory.
 </summary>
	<remarks>
 Classes implementing this interface represent the status of the name of an individual layer, table
 dataset or other file which is a part of a MapAction GIS data directory.
 
 Instances of these classes may or may not represent a name which is valid, or even syntatically
 correct. The intention is that these classes will assist the user in determining whether or not
 individual names are valid or not.
 
 It is not expected that that will be any public constructors for classes implenementing IDataName.
 In general, instances of IDataName would be created within the implenmentation of the
 IDataListConnection.getLayerDataNamesList() method.
 </remarks>
</member><member name="M:mapaction.datanames.api.RenamingDataException.getDataName">
	<summary>
 Returns the IDataName which could not be renamed.
 </summary>
	<returns>The IDataName which could not be renamed.</returns>
	<remarks>
 Returns the IDataName which could not be renamed
 </remarks>
</member><member name="T:mapaction.datanames.api.RenamingDataException">
	<summary>
 An Exception indicating at an error occured whilst attempting to rename
 the underlying data store.
 </summary>
	<remarks>
 An Exception indicating at an error occured whilst attempting to rename
 the underlying data store.
 
 Provides a convenence function to get hold of a reference to the offending 
 IDataname object.
 </remarks>
</member><member name="M:mapaction.datanames.api.ErroreousDataNameException.getNameStatus">
	<summary>
 Returns the status of the IDataName which caused the problem.
 </summary>
	<returns>Long. The status of the IDataName which caused the problem.</returns>
	<remarks>Returns the status of the IDataName which caused the problem.</remarks>
</member><member name="M:mapaction.datanames.api.ErroreousDataNameException.getDescriptionFromStatus(System.Int64)">
	<summary>
	</summary>
	<param name="lngBitsum"></param>
	<returns></returns>
	<remarks></remarks>
</member><member name="T:mapaction.datanames.api.ErroreousDataNameException">
	<summary>
 An exception which is thrown when certain operations are performed on IDataName
 which requires the IDataName to be either at a minimum, parsable or even valid.
 </summary>
	<remarks>
 An exception which is thrown when certain operations are performed on IDataName
 which requires the IDataName to be either at a minimum, parsable or even valid.
 
 It should be noted that IDataName.checkNameStatus() should never throw an
 ErroreousDataNameException.
 </remarks>
</member><member name="T:mapaction.datanames.api.dnNameStatus">
	<summary>
 BitFlags relating to the status of a particular Data Name. The status of a name
 is retrived by using IDataName.checkNameStatus() or one of the convenence wrapper
 methods.
 </summary>
	<remarks>
 BitFlags relating to the status of a particular Data Name. The status of a name
 is retrived by using IDataName.checkNameStatus() or one of the convenence wrapper
 methods.
 
 The status flags are arranged in four categories:
     INVALID = "One or more of the clauses (excluding Free Text) cannot be found in the Data Name Clause Lookup Tables
     SYNTAX_ERROR = "The format of the name cannot be understood. Individual clauses cannot be identified."
     WARN = "The name can be understood and the clauses are valid, but for some reason there is a risk that it will be misinterprited"
     INFO = "Other information about the name"
 
 All of the flags are prefixed with one of these four names. It is possible to test
 for all flags within a particular category by just testing agains the root. eg:
 
 ((myNameStatus And dnNameStatus.SYNTAX_ERROR) = dnNameStatus.SYNTAX_ERROR)
 
 will return true for SYNTAX_ERROR_CONTAINS_HYPHENS, SYNTAX_ERROR_TOO_FEW_CLAUSES,
 SYNTAX_ERROR_DOUBLE_UNDERSCORE and SYNTAX_ERROR_OTHER
 
 There is no "is valid" flag since depending on context this is any 
 combination of "not DATANAME_INVALID", "not DATANAME_SYNTAX_ERROR" 
 and maybe "not DATANAME_WARN"
 </remarks>
</member><member name="T:mapaction.datanames.api.dnListType">
	<summary>
 Describes the physical type of an IDataListConnection object.
 </summary>
	<remarks>
 Describes the physical type of an IDataListConnection object.
 </remarks>
</member><member name="T:mapaction.datanames.api.dnClauseLookupType">
	<summary>
 Describes the physical type of an IDataNameClauseLookup object.
 </summary>
	<remarks>
 Describes the physical type of an IDataNameClauseLookup object.
 </remarks>
</member><member name="T:mapaction.datanames.api.dnLookupTableError">
	<summary>
 Describes possible causes of the Lookup Table Exceptions
 </summary>
	<remarks>
 Describes possible causes of the Lookup Table Exceptions
 </remarks>
</member><member name="P:mapaction.datanames.api.DataNamingConstants.g_strAryClauseTableNames">
	<summary>
 An array of all of the data name clause tables names.
 </summary>
	<value></value>
	<returns>An array of all of the data name clause tables names.
 </returns>
	<remarks>An array of all of the data name clause tables names.
 </remarks>
</member><member name="P:mapaction.datanames.api.DataNamingConstants.g_htbDNStatusStrMessages">
	<summary>
 A collection of "user readable" messages describing the dataname status.
 </summary>
	<value></value>
	<returns></returns>
	<remarks>
 A collection of "user readable" messages describing the dataname status.
 
 The Dictionary(Of dnNameStatus, String) uses the dnNameStatus enumeration as the keys.
 </remarks>
</member><member name="P:mapaction.datanames.api.DataNamingConstants.g_lstDNNameStatusValues">
	<summary>
 A list of possible dnNameStatus values
 </summary>
	<value></value>
	<returns></returns>
	<remarks>A list of possible dnNameStatus values</remarks>
</member><member name="P:mapaction.datanames.api.DataNamingConstants.g_htbAllDataNameColumns">
	<summary>
 A structured collection of the DataColumns which describe all of the dataname 
 clause tables
 </summary>
	<value>A Hashtable. The Hashtable has entry for each dataname clause table, with
 the table name as the key. In each case the value is an ArrayList, of DataColumn 
 objects describing that table.
 </value>
	<returns></returns>
	<remarks>
 A structured collection of the DataColumns which describe all of the dataname 
 clause tables.
 
 The returned values is a Hashtable. The Hashtable has entry for each dataname 
 clause table, with the table name as the key. In each case the value is an 
 ArrayList, of DataColumn objects describing that table.
 </remarks>
</member><member name="M:mapaction.datanames.api.DataNamingConstants.initialiseDataColumnCollections">
	<summary>
 Creates a reference set of DataColumn objects for comparing any "live" tables against.
 </summary>
	<remarks></remarks>
</member>
</members>
</doc>